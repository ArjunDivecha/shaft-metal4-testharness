import Foundation
import UIKit

class ExportService {
    static let shared = ExportService()

    private init() {}

    // MARK: - Export All Files

    func exportResults(_ result: BenchmarkResult) -> [URL] {
        var exportedFiles: [URL] = []

        // Generate report.md
        if let reportURL = generateReportMarkdown(result) {
            exportedFiles.append(reportURL)
        }

        // Generate run.json
        if let jsonURL = generateRunJSON(result) {
            exportedFiles.append(jsonURL)
        }

        // Generate GitHub template
        if let templateURL = generateGitHubTemplate(result) {
            exportedFiles.append(templateURL)
        }

        return exportedFiles
    }

    // MARK: - Generate report.md

    private func generateReportMarkdown(_ result: BenchmarkResult) -> URL? {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
        let timestamp = dateFormatter.string(from: result.timestamp)

        let deviceInfo = DeviceInfo.shared
        let metalCap = MetalCapability.shared

        var markdown = """
        # Metal-4 Tensor API Test Results

        **Date:** \(timestamp)
        **Device:** \(deviceInfo.getDeviceModel()) (iOS \(deviceInfo.getIOSVersion()))
        **Metal:** Version \(metalCap.getMetalVersion()), Family \(metalCap.getMetalFamily())
        **Backend:** \(result.backend.displayName)
        **Model:** \(result.modelInfo.filename) (\(String(format: "%.2f", result.modelInfo.sizeGB)) GB)

        ## Performance Metrics

        - **Time to First Token (TTFT):** \(String(format: "%.0f", result.ttftMs)) ms
        - **Tokens per Second (TP/s):** \(String(format: "%.1f", result.tokensPerSecond))
        - **Total Tokens:** \(result.totalTokens)
        - **Peak Memory:** \(result.peakMemoryMB) MB
        - **Run Duration:** \(String(format: "%.1f", result.durationMs / 1000)) s

        ## Thermal Profile

        - **States Observed:** \(Set(result.thermalStates.map { $0.rawValue }).sorted().joined(separator: ", "))
        - **Throttling Events:** \(result.throttlingEvents)
        - **Final State:** \(result.thermalStates.last?.rawValue ?? "unknown")

        """

        // Add comparison section if available
        if let comparison = result.comparisonResult {
            markdown += """

            ## Correctness vs. \(comparison.baselineBackend.displayName)

            - **Token Match Rate:** \(String(format: "%.1f", comparison.matchPercentage))% (\(comparison.tokenMatchRatio))
            - **Edit Distance:** \(comparison.editDistance)
            - **Notes:** \(comparison.notes ?? "No divergence issues detected")

            """
        }

        // System summary
        markdown += """

        ## System Information

        \(deviceInfo.getSystemSummary())

        ## Metal Capability

        \(metalCap.getCapabilityInfo())

        ---

        Generated by Metal Tensor Harness v0.1.0
        """

        return writeToFile(content: markdown, filename: "report.md")
    }

    // MARK: - Generate run.json

    private func generateRunJSON(_ result: BenchmarkResult) -> URL? {
        let deviceInfo = DeviceInfo.shared
        let metalCap = MetalCapability.shared

        let metadata = RunMetadata(
            device: deviceInfo.getDeviceModel(),
            iosVersion: deviceInfo.getIOSVersion(),
            metalVersion: metalCap.getMetalVersion(),
            metalFamily: metalCap.getMetalFamily(),
            backend: result.backend
        )

        let modelInfo = RunJSON.ModelJSONInfo(
            path: result.modelInfo.filename,
            sizeBytes: result.modelInfo.sizeBytes,
            quant: result.modelInfo.quantization ?? "unknown",
            ctxLen: result.modelInfo.contextLength ?? 4096
        )

        let runConfig = RunJSON.RunConfig(
            promptId: "default", // TODO: Track actual prompt ID
            seed: 1234,
            tokensTarget: result.runType.targetTokens
        )

        let metrics = RunJSON.MetricsJSON(
            ttftMs: result.ttftMs,
            tpS: result.tokensPerSecond,
            totalTokens: result.totalTokens,
            timeMs: result.durationMs,
            peakMemMb: result.peakMemoryMB,
            thermalStates: result.thermalStates.map { $0.rawValue },
            throttledEvents: result.throttlingEvents
        )

        let runJSON = RunJSON(
            meta: metadata,
            model: modelInfo,
            run: runConfig,
            metrics: metrics,
            parity: result.comparisonResult,
            notes: nil
        )

        guard let jsonData = try? JSONEncoder().encode(runJSON),
              let jsonString = String(data: jsonData, encoding: .utf8) else {
            return nil
        }

        // Pretty print
        if let prettyData = try? JSONSerialization.jsonObject(with: jsonData),
           let prettyJSON = try? JSONSerialization.data(withJSONObject: prettyData, options: .prettyPrinted),
           let prettyString = String(data: prettyJSON, encoding: .utf8) {
            return writeToFile(content: prettyString, filename: "run.json")
        }

        return writeToFile(content: jsonString, filename: "run.json")
    }

    // MARK: - Generate GitHub Template

    private func generateGitHubTemplate(_ result: BenchmarkResult) -> URL? {
        let deviceInfo = DeviceInfo.shared
        let metalCap = MetalCapability.shared

        var template = """
        ### Device Testing Results

        **Device:** \(deviceInfo.getDeviceModel()) (iOS \(deviceInfo.getIOSVersion()))
        **Metal Version:** Metal \(metalCap.getMetalVersion()) (native tensor support)
        **Commit:** [Insert llama.cpp commit hash]
        **Backend:** \(result.backend.displayName)
        **Model:** \(result.modelInfo.filename), quant \(result.modelInfo.quantization ?? "unknown"); ctx \(result.modelInfo.contextLength ?? 4096)

        **Performance Metrics:**
        - TTFT: \(String(format: "%.0f", result.ttftMs)) ms
        - TP/s: \(String(format: "%.1f", result.tokensPerSecond))
        - Total tokens: \(result.totalTokens)
        - Peak memory: \(result.peakMemoryMB) MB
        - Thermal notes: \(result.thermalStates.last?.rawValue ?? "nominal")

        """

        if let comparison = result.comparisonResult {
            template += """
            **Correctness vs. \(comparison.baselineBackend.displayName):** \(String(format: "%.1f", comparison.matchPercentage))% match

            """
        }

        template += """
        **Logs:** See attached `run.json` and `report.md`

        **Repro steps:**
        1. Device: iPhone 17 Pro Max, iOS 26.0.1
        2. Model: \(result.modelInfo.filename)
        3. Backend: \(result.backend.displayName)
        4. Run type: \(result.runType.displayName)
        5. Results above

        ---
        Generated by Metal Tensor Harness v0.1.0
        """

        return writeToFile(content: template, filename: "github-template.md")
    }

    // MARK: - File Writing

    private func writeToFile(content: String, filename: String) -> URL? {
        let tempDir = FileManager.default.temporaryDirectory
        let fileURL = tempDir.appendingPathComponent(filename)

        do {
            try content.write(to: fileURL, atomically: true, encoding: .utf8)
            print("✅ Exported: \(filename)")
            return fileURL
        } catch {
            print("❌ Failed to export \(filename): \(error)")
            return nil
        }
    }

    // MARK: - Share Sheet

    func presentShareSheet(urls: [URL], from viewController: UIViewController) {
        let activityVC = UIActivityViewController(activityItems: urls, applicationActivities: nil)

        // For iPad
        if let popover = activityVC.popoverPresentationController {
            popover.sourceView = viewController.view
            popover.sourceRect = CGRect(x: viewController.view.bounds.midX,
                                        y: viewController.view.bounds.midY,
                                        width: 0, height: 0)
            popover.permittedArrowDirections = []
        }

        viewController.present(activityVC, animated: true)
    }
}
